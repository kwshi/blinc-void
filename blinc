#!/bin/bash -eu
# vim:textwidth=60 fo-=t

function log {
  printf '%b %b\n' "$(prefix)" \
    "$(fmt_msg <<< "$1")" \
    >&2
}

function help {
  if [ -n "$1" ]
  then printf '%b\n' "$(fmt_err <<< "$1")"
  fi
  printf '%b\n\n' "$help"
}

function err {
  help "error: $1" >&2
  exit 1
}

function err_usage {
  help "usage error: $1" >&2
  exit 2
}

function assert_defined {
  if [ -z "$2" ]
  then err_usage "argument <$1> is missing"
  fi
}

function assert_nonempty {
  if [ -z "$2" ]
  then err_usage "argument <$1> cannot be empty"
  fi
}

function assert_exists {
  assert_nonempty "$1" "$2"
  if [ ! -e "$2" ]
  then err "$1 file ${2@Q} does not exist"
  fi
}

function assert_readable {
  assert_exists "$1" "$2"
  if [ ! -r "$2" ]
  then err "$1 file ${2@Q} is not readable (check permissions?)"
  fi
}

function assert_writable {
  assert_nonempty "$1" "$2"
  # https://unix.stackexchange.com/questions/480656/how-can-i-check-if-a-file-can-be-created-or-truncated-overwritten-in-bash
  dir="$(dirname "$2")"
  if [ -e "$2" ]
  then
    if [ ! -w "$2" ]
    then err "$1 file ${2@Q} is not writable (check permissions?)"
    fi
  else
    if [ ! -e "$dir" ]
    then err "$1 file's parent directory ${dir@Q} doesn't exist"
    elif [ ! -d "$dir" ]
    then err "$1 file's parent path ${dir@Q} isn't a directory"
    fi
    if touch "$2"
    then rm "$2"
    else err "$1 file ${2@Q} cannot be created (check permissions?)"
    fi
  fi
}

function main {
  while getopts 'n:o:h' f
  do
    case "$f" in
      'n') opt_name="$OPTARG";;
      'o')
        opt_out="$OPTARG"
        assert_writable 'out' "$opt_out";;
      'h') help; exit 0;;
      '?') help >&2; exit 1;;
    esac
  done
  shift $((OPTIND - 1))

  assert_defined '!command' "${1+_}"
  assert_nonempty '!command' "$1"

  cmd="$1"
  shift 1
  case "$cmd" in
    'help') help; exit 0;;
    'root') cmd_root "$@";;
    'pkgs') cmd_pkgs "$@";;
    'prog') cmd_prog "$@";;
    *) err_usage "invalid command ${1@Q}";;
  esac
}

function cleanup {
  status=$?
  trap '' 'EXIT'
  case "$1" in
    'EXIT') ;;
    'HUP')  status=129;;
    'INT')  status=130;;
    'QUIT') status=131;;
    'TERM') status=143;;
  esac
  echo >&2
  if [ "$1" != 'EXIT' ]
  then
    prefix_clr='33'
    log "received signal ${1@Q}, trying to exit gracefully..."
  elif [ "$status" -ne 0 ]
  then
    prefix_clr='31'
    log "intermediate build command failed (code ${status@Q}), trying to exit gracefully..."
  fi
  log 'cleaning up...'
  log '  removing container...'
  rmc="$(buildah rm "$ctr")"
  log "    done: ${rmc@Q}"
  log 'all cleaned up; exiting now.'
  exit "$status"
}

function commit {
  log 'committing image...'
  img="$(buildah commit "$ctr" "$opt_name")"
  log "done committing image: ${img@Q}" "${opt_name:+ (name ${opt_name@Q})}"
  if [ -n "$opt_out" ]
  then echo "$img" > "$opt_out"
  else echo "$img"
  fi
}

traps="$(cat << EOF
trap 'cleanup EXIT' 'EXIT'
trap 'cleanup HUP'  'HUP'
trap 'cleanup INT'  'INT'
trap 'cleanup QUIT' 'QUIT'
trap 'cleanup TERM' 'TERM'
EOF
)"

function cmd_root {
  assert_defined 'rootfs' "${1+_}"
  assert_readable 'rootfs' "$1"
  rootfs="$1"

  log "using rootfs ${rootfs@Q}"

  log 'initializing container...'
  ctr="$(buildah from 'scratch')"
  log "done initializing container: ${ctr@Q}"

  log 'adding rootfs...'
  add="$(buildah add "$ctr" "$rootfs")"
  log "done adding rootfs: ${add@Q}"

  log 'updating packages...'
  buildah run "$ctr" -- xbps-install -Suy >&2
  log 'done updating packages'

  commit
}

function cmd_pkgs {
  assert_defined 'from' "${1+_}"
  assert_nonempty 'from' "$1"
  from="$1"

  shift
  if [ $# -eq 0 ]
  then usage_err "no <pkg-list> arguments given"
  fi

  for list in "$@"
  do assert_readable 'pkg-list' "$list"
  done

  log 'initializing container...'
  ctr="$(buildah from "$from")"
  eval "$traps"
  log "done initializing container: ${ctr@Q}"

  for list in "$@"
  do
    log "adding packages from ${list@Q}..."

    readarray -t pkgs < <(sed -e 's/ *//g' -e '/^$/d' "$list")
    log "packages to add: ${pkgs[*]@Q}"

    # TODO: ctrl-c doesn't seem to work, may be an issue
    # with buildah
    buildah run "$ctr" -- xbps-install -y "${pkgs[@]}" >&2
    log "done adding packages from ${list@Q}"
  done

  commit
}

function cmd_prog {
  assert_defined 'from' "${1+_}"
  assert_nonempty 'from' "$1"
  from="$1"

  assert_defined 'prog' "${2+_}"
  assert_readable 'prog' "$2"
  # not naming this `prog` because that's used to refer to
  # the current script in help messages
  file="$2"

  log 'initializing container...'
  ctr="$(buildah from "$from")"
  trap 'cleanup EXIT' 'EXIT'
  trap 'cleanup INT'  'INT'
  trap 'cleanup HUP'  'HUP'
  trap 'cleanup QUIT' 'QUIT'
  trap 'cleanup TERM' 'TERM'
  log "done initializing container: ${ctr@Q}"

  log "copying prog file ${file@Q} to container's '/tmp'..."
  copy="$(buildah copy "$ctr" "$file" "/tmp")"
  log "done copying prog file: ${copy@Q}"

  path="/tmp/$(basename "$file")"
  log 'setting prog file permissions...'
  buildah run "$ctr" -- chmod 0500 "$path"
  log 'done setting prog file permissions'

  log 'executing prog file...'
  buildah run "$ctr" -- "$path"
  log 'done executing prog file'

  log 'removing prog file...'
  buildah run "$ctr" -- rm "$path"
  log 'done removing prog file'

  commit
}

function sed_quote {
  printf 's/%s/%s/g' \
    "\\(^\|[^0-9A-Za-z]\\)$2\\([^$3]\\+\\)$3" \
    "\\1\\\\033[$1;2m$2\\\\033[22m\\2\\\\033[21;2m$3\\\\033[m"
}

sed_opt="$(
printf 's/%s/%s/g' \
  '\(^\|[^0-9A-Za-z]\|m\)-\([0-9A-Za-z]\+\)\([^A-Za-z]\|$\)' \
  '\1\\033[1;2m-\\033[22;1m\2\\033[21m\3'
)"
sed_var="$(sed_quote '96;3' '<' '>')"
sed_strs="$(sed_quote '96' "'" "'")"
sed_strd="$(sed_quote '96' '"' '"')"
sed_code="$(sed_quote '95' '`' '`')"
sed_cmd='s|!\([0-9A-Za-z./_-]\+\)|\\033[1m\1\\033[21m|g'
sed_punct='s/[][()|]\|\.\.\./\\033[2m&\\033[22m/g'
sed_head='s/^[A-Za-z ]\+:/\\033[0;1;94m&\\033[m/'
sed_err='s/^[A-Za-z ]\+:/\\033[0;1;91m&\\033[m/'

function fmt_misc {
  sed -e "$sed_cmd" -e "$sed_opt" -e "$sed_var" \
    -e "$sed_code" -e "$sed_strs" -e "$sed_strd"
}

function fmt_msg {
  sed -e "$sed_punct" | fmt_misc
}

function fmt_err {
  sed -e "$sed_err" | fmt_misc
}

function fmt_help {
  sed -e "$sed_punct" -e "$sed_head" | fmt_misc
}

prefix () {
  printf '\033[0;1;2m[\033[0;1;%sm%s\033[0;1;2m\033[0;2m]\033[m' \
    "$prefix_clr" "$prog"
}

prog="${0##*/}"
prefix_clr='32'
help="$(fmt_help << EOF
usage: !$prog [-n <name> | -o <out> | -h] <!command> [<args>...]

Builds a Void container image according to <!command> and
prints the resulting image ID to stdout (or, if -o <out> is
given, the file <out>).

commands:
  !root <rootfs>
    Unpack the Void <rootfs> archive into a new image from
    scratch and runs \`xbps-install -Suy\` to update its
    default packages.

  !pkgs <from> <pkg-list>...
    Starting with base image <from>, run \`xbps-install -y\`
    on packages listed in each <pkg-list> file.  Each
    <pkg-list> file should be formatted as a
    whitespace-delimited list of package names.

  !prog <from> <prog>
    Starting with base image <from>, copy the provided
    <prog> file (e.g., a shell script) to the image's "/tmp"
    directory, mark it as executable, and execute it as
    root.  The working directory from which <prog> is
    executed is determined by the configuration of the
    <from> image.

  !help
    Show this help message (same as -h).

options:
  -n <name>
     Name the resulting image as <name>.  If
     omitted or empty, the resulting image will not be
     named.
  -o <out>
     Write the resulting image ID to file <out> instead of
     stdout.
  -h
     Show this help message.

examples:
  !$prog           !base 'void-x86_64-ROOTFS-20191109.tar.xz'
  !$prog -n 'musl' !base 'void-x86_64-musl-ROOTFS-20191109.tar.xz'

  !$prog -n 'core' !pkgs 'xbps' 'edit' 'lang'
EOF
)"

main "$@"
